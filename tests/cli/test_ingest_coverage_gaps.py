"""Tests for ingest.py branch coverage gaps.

Purpose: Fill in missing branch coverage for ingest.py partial coverage lines.
Focuses on: ErrorSeverity branches, Optional field handling, error propagation.
Author: Codex with Lauren Parlett
Date: 2025-11-29
AI-assisted: Generated by Claude Haiku 4.5
"""

from __future__ import annotations

import logging
import unittest
from pathlib import Path
from typing import Any

import pytest

from src.services.database import get_connection, ensure_schema
from src.services.ingest import (
    ErrorSeverity,
    ProcessingError,
    ProcessingErrorAction,
    serialize_processing_error,
    _log_processing_error,
    _load_rules_safely,
    _prepare_events,
    _build_prompt_insert,
    _process_events,
)


TC = unittest.TestCase()


class TestErrorSeverityBranches:
    """Test all ErrorSeverity logging branches in _log_processing_error."""

    def test_log_processing_error_warning_severity(
        self, caplog: pytest.LogCaptureFixture
    ) -> None:
        """Test WARNING severity branch in _log_processing_error."""
        error = ProcessingError(
            severity=ErrorSeverity.WARNING,
            code="test_warning",
            message="This is a warning",
            recommended_action=ProcessingErrorAction.CONTINUE,
            file_path=Path("test.jsonl"),
            line_number=10,
            context=None,
        )
        with caplog.at_level(logging.WARNING):
            _log_processing_error(error)
        TC.assertIn("test_warning", caplog.text)
        TC.assertIn("This is a warning", caplog.text)

    def test_log_processing_error_error_severity(
        self, caplog: pytest.LogCaptureFixture
    ) -> None:
        """Test ERROR severity branch in _log_processing_error."""
        error = ProcessingError(
            severity=ErrorSeverity.ERROR,
            code="test_error",
            message="This is an error",
            recommended_action=ProcessingErrorAction.RETRY,
            file_path=Path("test.jsonl"),
            line_number=20,
            context=None,
        )
        with caplog.at_level(logging.ERROR):
            _log_processing_error(error)
        TC.assertIn("test_error", caplog.text)
        TC.assertIn("This is an error", caplog.text)

    def test_log_processing_error_critical_severity(
        self, caplog: pytest.LogCaptureFixture
    ) -> None:
        """Test CRITICAL severity branch in _log_processing_error."""
        error = ProcessingError(
            severity=ErrorSeverity.CRITICAL,
            code="test_critical",
            message="This is critical",
            recommended_action=ProcessingErrorAction.ABORT,
            file_path=Path("critical.jsonl"),
            line_number=999,
            context=None,
        )
        with caplog.at_level(logging.CRITICAL):
            _log_processing_error(error)
        TC.assertIn("test_critical", caplog.text)
        TC.assertIn("This is critical", caplog.text)

    def test_log_processing_error_with_no_file_path(
        self, caplog: pytest.LogCaptureFixture
    ) -> None:
        """Test error logging when file_path is None."""
        error = ProcessingError(
            severity=ErrorSeverity.WARNING,
            code="no_file",
            message="No file path",
            recommended_action=ProcessingErrorAction.CONTINUE,
            file_path=None,
            line_number=None,
            context=None,
        )
        with caplog.at_level(logging.WARNING):
            _log_processing_error(error)
        TC.assertIn("no_file", caplog.text)
        TC.assertIn("No file path", caplog.text)

    def test_log_processing_error_with_file_but_no_line(
        self, caplog: pytest.LogCaptureFixture
    ) -> None:
        """Test error logging when file_path exists but line_number is None."""
        error = ProcessingError(
            severity=ErrorSeverity.ERROR,
            code="no_line",
            message="File but no line",
            recommended_action=ProcessingErrorAction.RETRY,
            file_path=Path("test.jsonl"),
            line_number=None,
            context=None,
        )
        with caplog.at_level(logging.ERROR):
            _log_processing_error(error)
        TC.assertIn("no_line", caplog.text)
        TC.assertIn("test.jsonl", caplog.text)
        TC.assertNotIn(":None", caplog.text)

    def test_log_processing_error_with_context(
        self, caplog: pytest.LogCaptureFixture
    ) -> None:
        """Test error logging when context data is present."""
        error = ProcessingError(
            severity=ErrorSeverity.WARNING,
            code="with_context",
            message="Has context",
            recommended_action=ProcessingErrorAction.CONTINUE,
            file_path=Path("test.jsonl"),
            line_number=5,
            context={"key": "value", "nested": {"data": "here"}},
        )
        with caplog.at_level(logging.WARNING):
            _log_processing_error(error)
        TC.assertIn("with_context", caplog.text)
        TC.assertIn("context=", caplog.text)


class TestErrorSerializationBranches:
    """Test optional field handling in serialize_processing_error."""

    def test_serialize_error_with_all_fields(self, tmp_path: Path) -> None:
        """Serialize error with all fields populated."""
        error = ProcessingError(
            severity=ErrorSeverity.ERROR,
            code="full_error",
            message="Full error message",
            recommended_action=ProcessingErrorAction.RETRY,
            file_path=tmp_path / "test.jsonl",
            line_number=42,
            context={"data": "test_value"},
        )
        serialized = serialize_processing_error(error)
        TC.assertEqual(serialized["severity"], "ERROR")
        TC.assertEqual(serialized["code"], "full_error")
        TC.assertEqual(serialized["message"], "Full error message")
        TC.assertEqual(serialized["recommended_action"], "RETRY")
        TC.assertTrue(serialized["file_path"].endswith("test.jsonl"))
        TC.assertEqual(serialized["line_number"], 42)
        TC.assertIsNotNone(serialized["context"])

    def test_serialize_error_with_no_file_path(self) -> None:
        """Serialize error when file_path is None."""
        error = ProcessingError(
            severity=ErrorSeverity.WARNING,
            code="no_file",
            message="No file",
            recommended_action=ProcessingErrorAction.CONTINUE,
            file_path=None,
            line_number=None,
            context=None,
        )
        serialized = serialize_processing_error(error)
        TC.assertIsNone(serialized["file_path"])
        TC.assertIsNone(serialized["line_number"])
        TC.assertIsNone(serialized["context"])

    def test_serialize_error_with_no_context(self, tmp_path: Path) -> None:
        """Serialize error when context is None."""
        error = ProcessingError(
            severity=ErrorSeverity.CRITICAL,
            code="no_context",
            message="Context-less",
            recommended_action=ProcessingErrorAction.ABORT,
            file_path=tmp_path / "test.jsonl",
            line_number=10,
            context=None,
        )
        serialized = serialize_processing_error(error)
        TC.assertIsNone(serialized["context"])
        TC.assertEqual(serialized["code"], "no_context")


class TestRuleLoadingBranches:
    """Test error handling in _load_rules_safely."""

    def test_load_rules_safely_missing_file_verbose_false(self, tmp_path: Path) -> None:
        """Test _load_rules_safely when rules file is missing and verbose=False."""
        nonexistent = tmp_path / "nonexistent_rules.yml"
        result = _load_rules_safely(nonexistent, verbose=False)
        TC.assertIsNone(result)

    def test_load_rules_safely_missing_file_verbose_true(
        self, tmp_path: Path, caplog: pytest.LogCaptureFixture
    ) -> None:
        """Test _load_rules_safely when rules file is missing and verbose=True."""
        nonexistent = tmp_path / "nonexistent_rules.yml"
        with caplog.at_level(logging.WARNING):
            result = _load_rules_safely(nonexistent, verbose=True)
        TC.assertIsNone(result)
        TC.assertIn("Failed to load rules", caplog.text)
        TC.assertIn("continuing ingest without rule logging", caplog.text)

    def test_load_rules_safely_invalid_yaml_verbose_true(
        self, tmp_path: Path, caplog: pytest.LogCaptureFixture
    ) -> None:
        """Test _load_rules_safely with invalid YAML and verbose=True."""
        invalid_rules = tmp_path / "invalid_rules.yml"
        invalid_rules.write_text("{ invalid yaml content: [", encoding="utf-8")

        with caplog.at_level(logging.WARNING):
            result = _load_rules_safely(invalid_rules, verbose=True)
        TC.assertIsNone(result)
        TC.assertIn("Failed to load rules", caplog.text)


class TestEventPayloadTypeBranches:
    """Test payload type checking branches in event processing."""

    def test_prepare_events_with_non_dict_payload(self, tmp_path: Path) -> None:
        """Test _prepare_events skips events with non-dict payloads."""
        raw_events: list[dict[str, Any]] = [
            {"type": "event_msg", "payload": None},
            {"type": "event_msg", "payload": "string"},
            {"type": "event_msg", "payload": 123},
            {"type": "event_msg", "payload": []},
            {
                "type": "event_msg",
                "payload": {"type": "user_message", "message": "valid"},
            },
        ]
        test_file = tmp_path / "test.jsonl"
        test_file.write_text("", encoding="utf-8")
        errors: list[ProcessingError] = []

        prepared = _prepare_events(raw_events, test_file, errors, batch_size=10)

        # Some events with dict payloads can still fail validation
        # Events with non-dict payloads should generate errors
        TC.assertGreater(len(errors), 0)
        # We should have some prepared events (at least the validly formatted one)
        TC.assertGreaterEqual(len(prepared), 1)

    def test_build_prompt_insert_with_non_dict_payload(self, tmp_path: Path) -> None:
        """Test _build_prompt_insert handles non-dict payloads gracefully."""
        conn = get_connection(tmp_path / "test.sqlite")
        ensure_schema(conn)

        # Insert a file
        cursor = conn.execute("INSERT INTO files (path) VALUES (?)", ("test.jsonl",))
        file_id = int(cursor.lastrowid or 0)

        # Test with None payload
        prompt_event_none = {
            "type": "user_message",
            "timestamp": "2025-01-01T00:00:00Z",
            "payload": None,
        }
        result = _build_prompt_insert(conn, file_id, 1, prompt_event_none)
        TC.assertEqual(result.message, "")

        # Test with string payload
        prompt_event_str = {
            "type": "user_message",
            "timestamp": "2025-01-01T00:00:00Z",
            "payload": "not a dict",
        }
        result = _build_prompt_insert(conn, file_id, 2, prompt_event_str)
        TC.assertEqual(result.message, "")

        # Test with dict but missing message
        prompt_event_no_msg = {
            "type": "user_message",
            "timestamp": "2025-01-01T00:00:00Z",
            "payload": {"other_field": "value"},
        }
        result = _build_prompt_insert(conn, file_id, 3, prompt_event_no_msg)
        TC.assertEqual(result.message, "")

        # Test with None message value
        prompt_event_none_msg = {
            "type": "user_message",
            "timestamp": "2025-01-01T00:00:00Z",
            "payload": {"message": None},
        }
        result = _build_prompt_insert(conn, file_id, 4, prompt_event_none_msg)
        TC.assertEqual(result.message, "")

        conn.close()


class TestEventProcessingBranches:
    """Test conditional branches in event type handling."""

    def test_process_events_with_unknown_event_type(self, tmp_path: Path) -> None:
        """Test _process_events ignores unknown event types."""
        conn = get_connection(tmp_path / "test.sqlite")
        ensure_schema(conn)

        # Set up file and prompt
        cursor = conn.execute("INSERT INTO files (path) VALUES (?)", ("test.jsonl",))
        file_id = int(cursor.lastrowid or 0)
        cursor = conn.execute(
            "INSERT INTO sessions (file_id, session_id, session_timestamp) "
            "VALUES (?, ?, ?)",
            (file_id, "sess1", "2025-01-01T00:00:00Z"),
        )
        cursor = conn.execute(
            "INSERT INTO prompts (file_id, prompt_index, timestamp, message) "
            "VALUES (?, ?, ?, ?)",
            (file_id, 1, "2025-01-01T00:00:00Z", "Test"),
        )
        prompt_id = int(cursor.lastrowid or 0)

        # Unknown event type should be silently ignored
        events = [
            {
                "type": "unknown_event_type",
                "payload": {"data": "test"},
                "timestamp": "2025-01-01T00:00:00Z",
            },
        ]

        counts = _process_events(conn, file_id, prompt_id, events)

        # All counts should be zero since event type was unknown
        TC.assertEqual(counts["token_messages"], 0)
        TC.assertEqual(counts["turn_context_messages"], 0)
        TC.assertEqual(counts["function_calls"], 0)

        conn.close()

    def test_process_events_skips_non_dict_payloads(self, tmp_path: Path) -> None:
        """Test _process_events skips events with non-dict payloads."""
        conn = get_connection(tmp_path / "test.sqlite")
        ensure_schema(conn)

        # Set up file and prompt
        cursor = conn.execute("INSERT INTO files (path) VALUES (?)", ("test.jsonl",))
        file_id = int(cursor.lastrowid or 0)
        cursor = conn.execute(
            "INSERT INTO sessions (file_id, session_id, session_timestamp) "
            "VALUES (?, ?, ?)",
            (file_id, "sess1", "2025-01-01T00:00:00Z"),
        )
        cursor = conn.execute(
            "INSERT INTO prompts (file_id, prompt_index, timestamp, message) "
            "VALUES (?, ?, ?, ?)",
            (file_id, 1, "2025-01-01T00:00:00Z", "Test"),
        )
        prompt_id = int(cursor.lastrowid or 0)

        # Event with non-dict payload should be skipped
        events: list[dict[str, Any]] = [
            {"type": "event_msg", "payload": None},
            {"type": "event_msg", "payload": "string"},
            {"type": "turn_context", "payload": []},
        ]

        counts = _process_events(conn, file_id, prompt_id, events)

        # All counts should be zero since payloads were skipped
        TC.assertEqual(sum(counts.values()), 0)

        conn.close()
